---
title:  主要功能
---

<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

This section summarizes main features and key functionality.

-   [高吞读读写](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_CF0E3E5C4F884374B8F2F536DD2A375C)
-   [可预计的低延时](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_9C5D669B583646F1B817284EB494DDA7)
-   [高延展性](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_EF7A73D35D1241289C9CA19EDDEBE959)
-   [持续可靠性](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_CEB4ABFF83054AF6A47EA2FA09C240B1)
-   [可靠的事件通知](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_86D2B8CC346349F3913209AF87648A02)
-   [基于数据存储的并行应用操作](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_A65B5F0DE8BF4AA6AFF16E3A75D4E0AD)
-   [Shared-Nothing的磁盘持久化](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_97CABBFF553647F6BBBC40AA7AF6D4C7)
-   [减少拥有成本](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_FCB2640F1BED4692A93F9300A41CE70D)
-   [Client/Server中的单跳(Single-Hop)机制](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_92A444D4B422434EBD5F81D11F32C1C7)
-   [Client/Server中的安全机制](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_577F601BC9854AA6B53CD3440F9B9A6A)
-   [多站点数据分发](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_091A306900D7402CAE5A46B5F9BFD612)
-   [持续查询（Continuous Querying）](product_intro.html#concept_3B5E445B19884680900161BDF25E32C9__section_FF4C3B6E26104C4D93186F6FFE22B321)
-   [跨编程语言数据共享](product_intro.html#mainfeatures_heterogeneousdatasharing)

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_CF0E3E5C4F884374B8F2F536DD2A375C" class="no-quick-link"></a>高吞吐读写

通过并行内存架构和高度优化的分布式基础架构提供读写吞吐。为了获得高吞吐读写，应用可以创建数据的动态副本， 通过针对读的高吞吐进行同步和异步复制，或者通过在许多系统成员上分区数据。 如果数据的访问在整个数据集合上基本平衡的话， 数据分区可以加倍总吞吐。吞吐的线性增加只会被网络带宽所限制。

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_9C5D669B583646F1B817284EB494DDA7" class="no-quick-link"></a>可预计的低延时

优化的缓存层把在进程之间和线程之间的上下文切换减少到了最小程度。通过在一个高分布的架构中最小化数据争抢的方式，管理数据。如果接收端可以跟上的话， 对等成员之间的通信是同步的， 这样会保证数据分发的延迟始终最小。为了减少GC（garbage collector）的压力，服务器以序列化的格式管理对象图。

为了保证一个订阅针对所有订阅的客户端只分发一次， 订阅管理 (注册兴趣interest registration 和 持续查询continuous queries) 在整个服务器的数据存储中分区管理。 这样的机制改进了CPU的利用率和带宽的利用率， 从而增加了吞吐，也减少了客户端订阅的延迟。

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_EF7A73D35D1241289C9CA19EDDEBE959" class="no-quick-link"></a>高延展性

通过在很多成员上的数据动态分区和将数据负载均匀地传播到服务器上， 获得了延展性。针对“热”数据，你可以通过配置让数据创建更多的副本以获得动态展开。 你也可以以分布式方式运行一个应用的操作， 让它靠近所需要的数据。

如果你需要支持高且不可预测的客户端并发，你可以增加管理数据的服务器数量，同时在更多的服务器之间分发数据和相关的操作， 来获得低且可预测的响应时间。 基于各个服务器的负载情况，客户端的负载会被持续的均衡到服务器上。通过在服务器间的数据分区或者复制，客户端连接可以动态的移动到不同的服务器上，保证服务器获得据云的负载，客户端获得最好的响应时间。

你也可以通过应用异步的“后写”（write behind）把数据改变写到外部数据存储（例如数据库）上， 获得更高的延展性。这可以避免把所有更新按照顺序和冗余的方式放入队列的瓶颈。你也可以压缩更新事件，或者通过批量的方式把他们存入数据库。

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_CEB4ABFF83054AF6A47EA2FA09C240B1" class="no-quick-link"></a>持续可靠性

除了在内存中保证一致的数据副本，应用可以通过“shared nothing 磁盘架构”，以同步或者异步的方式， 在一个或多个成员上进行数据的持久化。所有的异步事件（存储转发事件）都会至少在两个成员上进行冗余副本管理， 这样如果一个服务器宕机， 则另一个服务器会进行接管。所有的客户端连接到逻辑服务器上， 如果服务器宕机或者服务器不响应，客户端连接则会自动连接到其他服务器上。
## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_86D2B8CC346349F3913209AF87648A02" class="no-quick-link"></a>可靠的事件通知

Publish/subscribe systems offer a data-distribution service where new events are published into the system and routed to all interested subscribers in a reliable manner. Traditional messaging platforms focus on message delivery, but often the receiving applications need access to related data before they can process the event. This requires them to access a standard database when the event is delivered, limiting the subscriber by the speed of the database.

Data and events are offered through a single system. Data is managed as objects in one or more distributed data regions, similar to tables in a database. Applications simply insert, update, or delete objects in data regions, and the platform delivers the object changes to the subscribers. The subscriber receiving the event has direct access to the related data in local memory or can fetch the data from one of the other members through a single hop.

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_A65B5F0DE8BF4AA6AFF16E3A75D4E0AD" class="no-quick-link"></a>Parallelized Application Behavior on Data Stores

You can execute application business logic in parallel on members. The data-aware function-execution service permits execution of arbitrary, data-dependent application functions on the members where the data is partitioned for locality of reference and scale.

By colocating the relevant data and parallelizing the calculation, you increase overall throughput. The calculation latency is inversely proportional to the number of members on which it can be parallelized.

The fundamental premise is to route the function transparently to the application that carries the data subset required by the function and to avoid moving data around on the network. Application function can be executed on only one member, in parallel on a subset of members, or in parallel across all members. This programming model is similar to the popular Map-Reduce model from Google. Data-aware function routing is most appropriate for applications that require iteration over multiple data items (such as a query or custom aggregation function).

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_97CABBFF553647F6BBBC40AA7AF6D4C7" class="no-quick-link"></a>Shared-Nothing Disk Persistence

Each distributed system member manages data on disk files independent of other members. Failures in disks or cache failures in one member do not affect the ability of another cache instance to operate safely on its disk files. This "shared nothing" persistence architecture allows applications to be configured such that different classes of data are persisted on different members across the system, dramatically increasing the overall throughput of the application even when disk persistence is configured for application objects.

Unlike a traditional database system, separate files are not used to manage data and transaction logs. All data updates are appended to files that are similar to transactional logs of traditional databases. You can avoid disk-seek times if the disk is not concurrently used by other processes, and the only cost incurred is the rotational latency.

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_FCB2640F1BED4692A93F9300A41CE70D" class="no-quick-link"></a>Reduced Cost of Ownership

You can configure caching in tiers. The client application process can host a cache locally (in memory and overflow to disk) and delegate to a cache server farm on misses. Even a 30 percent hit ratio on the local cache translates to significant savings in costs. The total cost associated with every single transaction comes from the CPU cycles spent, the network cost, the access to the database, and intangible costs associated with database maintenance. By managing the data as application objects, you avoid the additional cost (CPU cycles) associated with mapping SQL rows to objects.

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_92A444D4B422434EBD5F81D11F32C1C7" class="no-quick-link"></a>Single-Hop Capability for Client/Server

Clients can send individual data requests directly to the server holding the data key, avoiding multiple hops to locate data that is partitioned. Metadata in the client identifies the correct server. This feature improves performance and client access to partitioned regions in the server tier.

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_577F601BC9854AA6B53CD3440F9B9A6A" class="no-quick-link"></a>Client/Server Security

There may be multiple, distinct users in client applications. This feature accommodates installations in which clients are embedded in application servers and each application server supports data requests from many users. Each user may be authorized to access a small subset of data on the servers, as in a customer application where each customer can access only their own orders and shipments. Each user in the client connects to the server with its own set of credentials and has its own access authorization to the server cache.

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_091A306900D7402CAE5A46B5F9BFD612" class="no-quick-link"></a>多站点数据分发

Scalability problems can result from data sites being spread out geographically across a wide-area network (WAN). Models address these topologies, ranging from a single peer-to-peer cluster to reliable communications between data centers across the WAN. This model allows distributed systems to scale out in an unbounded and loosely coupled fashion without loss of performance, reliability or data consistency.

At the core of this architecture is the gateway sender configuration used for distributing region events to a remote site. You can deploy gateway sender instances in parallel, which enables an increase in throughput for distributing region events across the WAN. You can also configure gateway sender queues for persistence and high availability to avoid data loss in the case of a member failure.

## <a id="concept_3B5E445B19884680900161BDF25E32C9__section_FF4C3B6E26104C4D93186F6FFE22B321" class="no-quick-link"></a>持续查询

在一个类似JMS（Java Message Service）的消息系统中， 客户端订阅主题（topics）和队列（queues）。任何消息会通过主题分发给订阅者。通过应用使用OQL（Object Query Language）进行比较复杂的兴趣注册， Geode支持持续查询.

## <a id="mainfeatures_heterogeneousdatasharing" class="no-quick-link"></a>跨编程语言数据共享

不需要一个类似SOAP 或 XML的数据转化层， C#, C++ 和 Java 应用就可以分享应用业务对象。通过JAVA实现的服务器端操作，提供了一个针对 C++ 和 .NET应用的唯一的本机缓存。应用程序对象可以在C ++进程堆中进行管理，并使用对象的通用“在线”表示分发给其他进程。一个C++序列化的对象可以直接被反序列化成一个对等的Java或者C#对象。在一个编程语言中的一个业务对象上的变化， 可以向其他支持的编程语言编写的应用激发一个可靠的通知。
